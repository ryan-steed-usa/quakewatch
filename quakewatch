#!/usr/bin/python3

"""
This program displays a list of recent earthquakes.
Parses GeoJSON API Endpoint from https://earthquake.usgs.gov
and displays the result as optional color coded list in the terminal.
Color requires a terminal that supports 256 colors.

The PAGER status colors are taken from https://earthquake.usgs.gov/data/pager/background.php
The suggested levels of response are:
no response needed -> green,
local/regional     -> yellow,
national           -> orange,
international      -> red
"""

import argparse
import dataclasses
import errno
import os
import sys
import time
from datetime import datetime, timezone
import requests
from tabulate import tabulate

# small performance optimization
tabulate.WIDE_CHARS_MODE = False

# constants
VERSION = '2.0'
DESCRIPTION = '''
Monitor recent earthquakes reported by USGS at https://earthquake.usgs.gov.
If no arguments are specified, the significant earthquakes for the day (--day)
is output by default.

USGS has developed PAGER: an automated system for rapidly estimating impact,
exposure, fatalities, and losses. Color-coded alerting determines the
suggested levels of response: no response needed (green), local/regional (yellow),
national (orange), or international (red).

+-------------------------+----------------------+---------------------------+
| Alert Level and Color   | Estimated Fatalities | Estimated Losses (USD)    |
+-------------------------+----------------------+---------------------------+
| Red                     | 1,000+               | $1 billion+               |
| Orange                  | 100 - 999            | $100 million - $1 billion |
| Yellow                  | 1 - 99               | $1 million - $100 million |
| Green                   | 0                    | < $1 million              |
+-------------------------+----------------------+---------------------------+
'''
QUAKECOLORS = {
    # pager
    'green': '\033[38;5;046m',
    'orange': '\033[38;5;208m',
    'red': '\033[38;5;009m',
    'reset': '\033[0m',
    'yellow': '\033[38;5;011m',
    # magnitude
    'mag8': '\033[38;5;201m',
    'mag7': '\033[38;5;001m',
    'mag6': '\033[38;5;196m',
    'mag5': '\033[38;5;202m',
    'mag4': '\033[38;5;226m',
    'mag3': '\033[38;5;216m',
    'mag2': '\033[38;5;033m',
    'mag1': '\033[38;5;006m'
}
PAGERS = ('red', 'orange', 'yellow', 'green')
UNITS = ('hour', 'day', 'week', 'month')
MAGS = (45, 25, 10)
DEFAULT_TIME_FORMAT = '%Y-%m-%d %H:%M:%S'

# classes
@dataclasses.dataclass
class QwState:
    """use class to store global states"""
    pageralerts: list
    alerted: bool = False
    enablecolor: bool = True
    magalert: float = 666.666
    localtime: bool = True
    refresh: int = 60
    runonce: bool = False
    timeout: int = 10
    timeformat: str = DEFAULT_TIME_FORMAT

# functions
def get_color(color):
    """conditionally returns an earthquake color"""
    if QwState.enablecolor:
        return QUAKECOLORS[color]
    return ''

def get_sites():
    # available API endpoints
    """generate site URLs"""
    # URLs
    url = {}
    for unit in UNITS:
        for mag in MAGS:
            url[f'{unit}{mag}'] = \
                f'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/{mag/10}_{unit}.geojson'
        url[f'all_{unit}'] = \
            f'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_{unit}.geojson'
        url[f'significant_{unit}'] = \
            f'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_{unit}.geojson'
    return url

def init_args(parser):
    """initialize arguments"""
    parser.add_argument('-p', '--pager', help=f'enable audible terminal bell for desired pager,\
            valid pagers are {PAGERS}', type=str, nargs='+')
    parser.add_argument('-m', '--magnitude', help='enable audible terminal bell for specified\
            magnitude threshold, value >= mag will trigger the bell', type=float)
    parser.add_argument('-f', '--follow', help='enable follow mode like tail, (default: False)',\
            action='store_true')
    parser.add_argument('-l', '--localtime', help=f'display timestamps in local timezone, (default:\
            {QwState.localtime})', action='store_true')
    parser.add_argument('-r', '--refresh', help=f'set the API request refresh rate in seconds,\
            minimum 60 (default: {QwState.refresh})', type=int, nargs=1)
    parser.add_argument('-ro', '--run-once', help='disable watch and run a single loop (default:\
            False)', action='store_true', default=False)
    parser.add_argument('-t', '--timeout', help=f'set the API request timeout value in seconds,\
            minimum 10 (default: {QwState.timeout})', type=int, nargs=1)
    parser.add_argument('--time-format', help=f'set an strptime compatible string to customize\
            the time format (default: {DEFAULT_TIME_FORMAT.replace("%", "%%")})', type=str)
    parser.add_argument('--color', help='control color output (default: True)',\
            type=bool, action=argparse.BooleanOptionalAction, default=True)
    parser.add_argument('--version', action='version', version=f'%(prog)s {VERSION}')

    group = parser.add_mutually_exclusive_group()
    for unit in UNITS:
        for mag in MAGS:
            group.add_argument(f'-{unit[0]}{mag}', f'--{unit}{mag}', help=f'show earthquakes >=\
                    M{mag / 10:.1f} of the last {unit}', action='store_true')
        group.add_argument(f'-{unit[0]}s', f'--{unit}', help=f'show significant earthquakes of \
                the {unit}', action='store_true')
        group.add_argument(f'-{unit[0]}a', f'--{unit}-all', help=f'show all earthquakes of the \
                last {unit}', action='store_true')
    return parser.parse_args()

def get_earthquake(feature):
    """returns a list of properties for one earthquake"""
    properties = feature['properties']

    # time is given in milliseconds since epoch
    utctime = datetime.fromtimestamp(properties['time'] / 1000, timezone.utc)
    localtime = utctime.astimezone()
    timestamp = localtime if QwState.localtime else utctime

    # colorize magnitude
    magnitude = properties['mag']
    magstr = f'{magnitude:0.2f}'

    # send terminal bell based on magnitude
    if magnitude >= QwState.magalert and QwState.alerted is False:
        print('\a', end='')
        QwState.alerted = True # page only once per refresh

    if magnitude >= 8.5:
        magnitude = f'{get_color('mag8')}{magstr}{get_color('reset')}'
    elif magnitude >= 7.5:
        magnitude = f'{get_color('mag7')}{magstr}{get_color('reset')}'
    elif magnitude >= 6.5:
        magnitude = f'{get_color('mag6')}{magstr}{get_color('reset')}'
    elif magnitude >= 5.5:
        magnitude = f'{get_color('mag5')}{magstr}{get_color('reset')}'
    elif magnitude >= 4.5:
        magnitude = f'{get_color('mag4')}{magstr}{get_color('reset')}'
    elif magnitude >= 3.5:
        magnitude = f'{get_color('mag3')}{magstr}{get_color('reset')}'
    elif magnitude >= 2.5:
        magnitude = f'{get_color('mag2')}{magstr}{get_color('reset')}'
    elif magnitude >= 1.5:
        magnitude = f'{get_color('mag1')}{magstr}{get_color('reset')}'
    else:
        magnitude = magstr

    # alert property is the PAGER status
    alertprop = properties['alert']
    if isinstance(alertprop, str) and alertprop.lower() in PAGERS:
        alert = f'{get_color(alertprop)}{alertprop.upper()}{get_color('reset')}'
        if alertprop.lower() in QwState.pageralerts and QwState.alerted is False:
            print('\a', end='')
            QwState.alerted = True
    else:
        alert = '-'

    return [timestamp.strftime(QwState.timeformat), magnitude, properties['place'],
            alert, properties['url']]

def print_table(url, follow):
    """prints the table of all earthquakes"""
    req = requests.get(url, timeout=QwState.timeout)
    earthquakes = req.json()
    currenttime = datetime.now() if QwState.localtime else datetime.now(timezone.utc)
    quakelist = list(map(get_earthquake, earthquakes['features']))
    tz_name = time.localtime().tm_zone if QwState.localtime else str(currenttime.tzinfo)
    quakeheaders = (f"Time ({tz_name})", 'Mag', 'Location', 'PAGER', 'More info')

    if not follow:
        os.system('clear')

    refreshstr = ''
    if not QwState.runonce:
        refreshstr = f', refreshing every {QwState.refresh}s'

    print(f'{earthquakes['metadata']['title']}{refreshstr}')
    print(f'Current Time ({tz_name}): {currenttime.strftime(QwState.timeformat)}')
    print(f'Events found: {len(quakelist)}')

    if not follow:
        print(tabulate(quakelist, headers=quakeheaders, floatfmt='.1f'))
    else:
        print(' | '.join(quakeheaders))
        for x in quakelist:
            print(' | '.join(x))

def process_args(parser, args):
    """process arguments"""
    if isinstance(args.pager, list):
        for pager in args.pager:
            if not pager in PAGERS:
                print(f"{parser.prog}: error: argument -p/--pager: requires input of {PAGERS} not:\
 '{pager}'", file=sys.stderr)
                sys.exit(1)
        QwState.pageralerts = args.pager
    if args.refresh:
        if args.run_once:
            print(f"{parser.prog}: error: arguments -r/--refresh and -ro/--run-once cannot be used\
 simultaneously", file=sys.stderr)
            sys.exit(1)
        if args.refresh[0] > QwState.refresh:
            QwState.refresh = args.refresh[0]
        elif not args.refresh[0] == QwState.refresh:
            print(f"{parser.prog}: error: argument -r/--refresh: requires minimum value\
 '{QwState.refresh}' not: '{args.refresh[0]}'", file=sys.stderr)
            sys.exit(1)
    if args.timeout:
        if args.timeout[0] > QwState.timeout:
            QwState.timeout = args.timeout[0]
        elif not args.timeout[0] == QwState.timeout:
            print(f"{parser.prog}: error: argument -t/--timeout: requires minimum value\
 '{QwState.timeout}' not: '{args.timeout[0]}'", file=sys.stderr)
            sys.exit(1)
    if args.time_format:
        if validate_time_format(args.time_format):
            QwState.timeformat = args.time_format
        else:
            print(f"{parser.prog}: error: argument --time-format: requires strftime format\
 like '{DEFAULT_TIME_FORMAT}' not: '{args.time_format}'", file=sys.stderr)
            sys.exit(1)

def select_site(args):
    """parse args to select a site"""
    urls = get_sites()
    site = urls['significant_day']
    for unit in UNITS:
        for mag in MAGS:
            if getattr(args, f'{unit}{mag}', True):
                site = urls[f'{unit}{mag}']
        if getattr(args, f'{unit}', True):
            site = urls[f'significant_{unit}']
        if getattr(args, f'{unit}_all', True):
            site = urls[f'all_{unit}']
    return site

def validate_time_format(timefmt):
    """test a strptime string format"""
    timestr = datetime.now().strftime(timefmt)
    try:
        datetime.strptime(timestr, timefmt)
        return True
    except ValueError:
        return False

def main():
    """main function to parse arguments and watch for earthquakes"""
    sys.stdout.reconfigure(line_buffering=True) # enable line buffering

    parser = argparse.ArgumentParser(description=DESCRIPTION, \
            formatter_class=argparse.RawDescriptionHelpFormatter)

    QwState.pageralerts = []
    args = init_args(parser)
    site = select_site(args)
    process_args(parser, args)

    QwState.enablecolor = args.color
    QwState.localtime = args.localtime
    QwState.runonce = args.run_once
    if isinstance(args.magnitude, float):
        QwState.magalert = args.magnitude

    while True:
        try:
            print_table(site, args.follow)
            if args.follow and not args.run_once:
                print()
            sys.stdout.flush() # flush for pipe compatibility
            QwState.alerted = False
            if args.run_once:
                break
            time.sleep(QwState.refresh)
        except KeyboardInterrupt:
            print(flush=True) # this puts the prompt on the next line
            break
        except BrokenPipeError:
            sys.stderr.close() # handle broken pipe gracefully
            raise

if __name__ == "__main__":
    try:
        main()
    except IOError as e:
        if e.errno == errno.EPIPE:
            # ignore pipe error trace
            pass
